# С клавиатуры вводится два числа K и N. Квадратная матрица А(N,N), состоящая из 4-х равных по размерам подматриц, B,C,D,E заполняется случайным образом целыми числами в интервале [-10,10]. Для отладки использовать не случайное заполнение, а целенаправленное.
# Вид матрицы А: E B
#                D C

# Для простоты все индексы в подматрицах относительные.
# По сформированной матрице F (или ее частям) необходимо вывести не менее 3 разных графиков.
# Программа должна использовать функции библиотек numpy  и mathplotlib

# Формируется матрица F следующим образом: скопировать в нее А и если в С количество положительных элементов в четных столбцах, чем количество отрицательных  элементов в нечетных столбцах, то поменять местами С и В симметрично,
# иначе С и Е поменять местами несимметрично. При этом матрица А не меняется.
# После чего если определитель матрицы А больше суммы диагональных элементов матрицы F, то вычисляется выражение: A*AT – K * F*A-1, иначе вычисляется выражение (К*A-1 +G-FТ)*K, где G-нижняя треугольная матрица, полученная из А.
# Выводятся по мере формирования А, F и все матричные операции последовательно.


import numpy as np
import matplotlib.pyplot as plt


# Генерация матрицы A
def generate_matrix(N):
    A = np.zeros((N, N))  # Создание квадратной матрицы A и заполнение ее нулями

    # Заполнение подматрицы B, C, D, E случайными числами
    for i in range(N):
        for j in range(N):
            if i >= N // 2 and j < N // 2:
                A[i, j] = np.random.randint(-10, 10)  # Подматрица B
            elif i >= N // 2 and j >= N // 2:
                A[i, j] = np.random.randint(-10, 10)  # Подматрица C
            elif i < N // 2 and j >= N // 2:
                A[i, j] = np.random.randint(-10, 10)  # Подматрица D
            else:
                A[i, j] = np.random.randint(-10, 10)  # Подматрица E
    return A


def form_matrix_F(A):
    N = A.shape[0]
    C = A[N // 2:, :N // 2]

    # Подсчет количества положительных и отрицательных элементов
    pos_count_area2 = np.sum(C[:, ::2] > 0)  # Сумма положительных элементов в четных столбцах области 2 подматрицы C
    neg_count_area4 = np.sum(C[:, 1::2] < 0)  # Сумма отрицательных элементов в нечетных столбцах области 4 подматрицы C

    if pos_count_area2 > neg_count_area4:  # Проверка условия
        C[:, :N // 4], C[:, 3 * N // 4:] = C[:, 3 * N // 4:], C[:, :N // 4]

    return A


def plot_matrix(matrix):
    plt.imshow(matrix, cmap='viridis')
    plt.colorbar()
    plt.show()

def plots_mtarix(matrix):
    plt.hist(matrix)
    plt.colorbar()
    plt.show()

def plrts_matrix(matrix):
    plt.pie(matrix)
    plt.colorbar()
    plt.show()


def main():
    K = int(input("Введите число K: "))
    N = int(input("Введите размер матрицы N: "))

    A = generate_matrix(N)
    print("\nМатрица A:\n", A)
    plot_matrix(A)
    plrts_matrix(A)
    plots_mtarix((A))

    F = form_matrix_F(A.copy())
    print("\nМатрица F:\n", F)
    plot_matrix(F)
    plrts_matrix((A))
    plots_mtarix(A)

main()
